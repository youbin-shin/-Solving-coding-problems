# D4

### 3347. 올림픽 종목 투표

```python
for t in range(1, int(input()) + 1):
    N, M = map(int, input().split())
    A = list(map(int, input().split()))
    vote = [0] * N
    B = list(map(int, input().split()))

    for b in B:
        for i in range(N):
            if A[i] <= b:
                vote[i] += 1
                break
    print(vote)

    print('#{} {}'.format(t, vote.index(max(vote))+1))
```

### 4408. 자기 방으로 돌아가기

```python
for t in range(1, int(input()) + 1):
    N = int(input())
    rooms = [0] * 201
    for _ in range(N):
        start, end = map(int, input().split())
        if start > end:
            start, end = end, start
        if start%2 == 0:
            start -= 1
        for i in range(start, end+1, 2):
            rooms[int(i/2)] += 1

    print('#{} {}'.format(t, max(rooms)))
```

### 3349. 최솟값으로 이동하기

```python
for t in range(int(input())):
    W, H, N = map(int, input().split())
    cnt = 0
    x, y = map(int, input().split())
    for i in range(N-1):
        xn, yn = map(int, input().split())
        dx = x - xn
        dy = y - yn
        if dy*dx > 0:
            cnt += max(abs(dx), abs(dy))
        else:
            cnt += abs(dx) + abs(dy)
        x, y = xn, yn

    print('#{} {}'.format(t+1, cnt))
```

### 4613. 러시아 국기 같은 깃발

```python
# teacher solution 1
for t in range(int(input())):
    N, M = map(int, input().split())
    arr = [input() for _ in range(N)]

    ans = N*M
    for i in range(0, N-3+1):
        for j in range(i+1, N-2+1):
            cnt = 0
            for r in range(0, i+1):
                for c in range(M):
                    if arr[r][c] != 'W': cnt += 1
            for r in range(i+1, j+1):
                for c in range(M):
                    if arr[r][c] != 'B': cnt += 1

            for r in range(j+1, N):
                for c in range(M):
                    if arr[r][c] != 'R': cnt += 1
            ans = min(ans, cnt)
    print('#{} {}'.format(t+1,ans))
```

```python
# teacher solution 2 - 누적합 이용
for t in range(int(input())):
    N, M = map(int, input().split())
    arr = [input() for _ in range(N)]

    w = [0] * N
    b = [0] * N
    r = [0] * N
    for i in range(N):
        w[i] = arr[i].count('W')
        b[i] = arr[i].count('B')
        r[i] = M - w[i] - b[i]

    for i in range(1, N):
        w[i] += w[i - 1]
        b[i] += b[i - 1]
        r[i] += r[i - 1]

    ans = N * M
    for i in range(0, N-3+1):
        for j in range(i+1, N-2+1):
            # 전체 칸 수 에서 바꿀 필요 없는 칸수 빼서 구하기
            cnt = M * (i+1) - w[i]
            cnt += M * (N - 1 - (j+1) + 1) - (r[N-1] - r[j])

            ans = min(ans, cnt)
    print('#{} {}'.format(t+1,ans))
```

### 1249. [S/W 문제해결 응용] 4일차 - 보급로

DFS에서의 Q의 개념과 Dijkstra 를 이용하여 해결한 코드

```python
for tc in range(int(input())):
    N = int(input())
    road = [list(map(int, input())) for _ in range(N)] # 보급로관련 데이터받기
    INF = float('inf')
    dist = [[INF] * N for _ in range(N)]
    visited = [[0]*N for _ in range(N)]
    q = []
    q.append([0, 0])
    dist[0][0] = road[0][0]
    while q:
        x, y = q.pop(0)
        visited[x][y] = 1
        dir = [[1, 0], [0, -1], [-1, 0], [0, 1]]
        for d in range(4):
            nx = x + dir[d][0]
            ny = y + dir[d][1]
            if 0<=nx<N and 0<=ny<N: 
                if dist[nx][ny] > dist[x][y] + road[nx][ny]: # 비교하며 업데이트
                    dist[nx][ny] = dist[x][y] + road[nx][ny]
                    q.append([nx, ny])
    print('#{} {}'.format(tc+1, dist[N-1][N-1]))
```

### 1486. 장훈이의 높은 선반

```python
def backtrack(k, hsum):
    global result
    if hsum >= shelf: # 가지치기 (없어도 동작함 => 없애면 메모리는 적게 사용하나 실행시간은 더 빨라진다.)
        if hsum - shelf < result: # 선반과 키 합의 차이가 최소 차이값보다 작으면 변경
            result = hsum - shelf
            return
    if k == people: 
        if hsum >= shelf and hsum - shelf < result:
            result = hsum - shelf
    else:  # 조합 이용
        backtrack(k + 1, hsum + heights[k]) # k번째 점원 포함
        backtrack(k + 1, hsum) # k 번째 점원 포함 x


for tc in range(int(input())):
    people, shelf = map(int, input().split())
    heights = list(map(int, input().split()))
    result = 99999999999999
    if shelf >= sum(heights): # 키를 다 합쳐도 선반보다 작은 경우 바로 계산하기
        result = shelf - sum(heights)
    else:
        backtrack(0, 0)
    print('#{} {}'.format(tc+1, result))
```

### 1251. [S/W 문제해결 응용] 4일차 - 하나로

```python
import heapq
for tc in range(int(input())):
    # 입력받기
    V = int(input())
    adj = {i: [] for i in range(V)}  # 인접리스트
    xlst = list(map(int, input().split()))
    ylst = list(map(int, input().split()))
    tax = float(input())
    for i in range(V):
        for j in range(i+1, V):
            s, e = i, j # 시작정점, 끝정점
            c = ((xlst[s]-xlst[e])*(xlst[s]-xlst[e]) + (ylst[s]-ylst[e])*(ylst[s]-ylst[e])) * tax #가중치
            adj[s].append([e, c])
            adj[e].append([s, c])
    # 계산하기
    # key, mst, 우선순위 큐 준비
    INF = float('inf')
    key = [INF] * V
    mst = [False] * V
    pq = []
    # 시작점 선택 : 0번 선택
    key[0] = 0
    heapq.heappush(pq, (0, 0))
    result = 0
    while pq:
        # 최소값 찾기
        k, node = heapq.heappop(pq)  # 가장 작은값 꺼낸다. (key, u)
        if mst[node]: continue  # old 한 정보면 스킵
        # mst로 선택
        mst[node] = True
        result += k
        # key 값을 갱신 => key 배열/큐
        for dest, wt in adj[node]:  # dest 가고자하는 곳, wt 가중치
            if not mst[dest] and key[dest] > wt:
                key[dest] = wt
                # 큐 갱신 => 새로운 (key, 정점) 삽입 (필요없는 원소는 스킵)
                heapq.heappush(pq, (key[dest], dest))
    print('#{} {}'.format(tc+1,int(result+0.5))) # 반올림해주기!!
```

