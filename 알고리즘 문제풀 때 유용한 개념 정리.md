# 알고리즘 문제풀 때 유용한 개념 정리

> 알고리즘 문제 풀면서 필요하거나 유용한 개념들을 정리합니다.

## 자주 사용하는 라이브러리 정리

### sys

#### 파일 input 입력하기

```python
import sys
sys.stdin = ("파일명", "r")
```

#### 재귀함수 사용할 경우 최대 재귀 깊이 설정하기

- 수동으로 늘려줄 수 있다. 
- 코드 상단에 적어야 한다.

```python
sys.setrecursionlimit(100000)
```



### combinations

```python
from itertools import combinations
numbers = [1, 2, 3, 4, 5]
test = list(combinations(numbers, 3)) # numbers의 개수를 n이라 할 때 nC3한 경우를 모두 test 저장한다.
```

```python
# 참고
# 알고리즘
def comb(lst, n): # lst 안에서 n개를 택하는 경우
    ret = []
    if n > len(lst): return ret

    if n == 1:
        for i in lst:
            ret.append([i])
    elif n > 1:
        for i in range(len(lst) - n + 1):
            for temp in comb(lst[i + 1:], n - 1):
                ret.append([lst[i]] + temp)

    return ret


lst = comb([1, 2, 3], 2)

print(lst) # [[1, 2], [1, 3], [2, 3]]
```



### deepcopy

```python
from copy import deepcopy
a = [1, 2, 3, 4, 5]
b = deepcopy(a) # b = [1, 2, 3, 4, 5]
```



## 진수 변환

### 10진수 → 2진수, 8진수, 16진수

#### 1. `bin()`, `oct()`, `hex()`내장 함수 이용

```python
print(bin(10)) # 0b1010
print(oct(10)) # 0o12
print(hex(10)) # 0xa
print(hex(16)) # 0x10
```

#### 2. `format()` 내장함수 이용

```python
print(format(8, '#b')) # 0b1000
print(format(8, '#o')) # 0o10
print(format(8, '#x')) # 0x8

# #을 제거해주면 변환된 값 자체만 출력 가능하다.
print(format(8, 'b')) # 1000
print(format(8, 'o')) # 10
print(format(8, 'x')) # 8
```

### 2진수, 8진수, 16진수 → 10진수

#### `int` 함수 이용

```python
print(int('0b1010', 2)) # 10
print(int('0o12', 8)) # 10
print(int('0xa', 16)) # 10
```



## error 정리

- TypeError: 'list' object is not callable
  - 원인: 위에서 선언한 변수를 함수처럼 쓰려고 한 경우
  - 해결방법: 중복으로 사용된 변수, 함수이름이 없는지 확인하기

## 문제 풀면서 배운 내용

- bfs에서 while q 사용시 return None 이 될수 있다는 것 잊지말기

  - 이 과정에서 결과를 sort하면 런타임에러 발생

  - 참고) bfs 이용한 최단거리 계산 알고리즘

    ```python
    def bfs(s):
        q = [s]
        dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        visited = [[0] * 4 for _ in range(4)]
        visited[s[0]][s[1]] = 1
        while q:
            # for i in range(4):
            #     print(visited[i])
            # print()
            x, y = q.pop(0)
            if [x, y] == [3, 3]:
                print(visited[x][y])
                break
            for i in range(4):
                nx = x + dirs[i][0]
                ny = y + dirs[i][1]
                if 0 <= nx < 4 and 0<= ny < 4:
                    if visited[nx][ny] == 0:
                        visited[nx][ny] = visited[x][y] + 1
                        q.append([nx, ny])
    
    
    a = [[0] * 4 for _ in range(4)]
    bfs([0, 0]) # [0, 0] ~ [3, 3] 까지 도달하는 최단 거리 계산하는 함수
    print(a)
    ```

    