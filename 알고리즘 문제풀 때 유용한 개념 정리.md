# 알고리즘 문제풀 때 유용한 개념 정리

> 알고리즘 문제 풀면서 필요하거나 유용한 개념들을 정리합니다.

## 자주 사용하는 라이브러리 정리

### sys

#### 파일 input 입력하기

```python
import sys
sys.stdin = ("파일명", "r")
```

#### 재귀함수 사용할 경우 최대 재귀 깊이 설정하기

- 수동으로 늘려줄 수 있다. 
- 코드 상단에 적어야 한다.

```python
sys.setrecursionlimit(100000)
```



### combinations

```python
from itertools import combinations
numbers = [1, 2, 3, 4, 5]
test = list(combinations(numbers, 3)) # numbers의 개수를 n이라 할 때 nC3한 경우를 모두 test 저장한다.
```

```python
# 참고
# 알고리즘
def comb(lst, n): # lst 안에서 n개를 택하는 경우
    ret = []
    if n > len(lst): return ret

    if n == 1:
        for i in lst:
            ret.append([i])
    elif n > 1:
        for i in range(len(lst) - n + 1):
            for temp in comb(lst[i + 1:], n - 1):
                ret.append([lst[i]] + temp)

    return ret


lst = comb([1, 2, 3], 2)

print(lst) # [[1, 2], [1, 3], [2, 3]]
```



### deepcopy

```python
from copy import deepcopy
a = [1, 2, 3, 4, 5]
b = deepcopy(a) # b = [1, 2, 3, 4, 5]
```



---

## error 정리

- TypeError: 'list' object is not callable
  - 원인: 위에서 선언한 변수를 함수처럼 쓰려고 한 경우
  - 해결방법: 중복으로 사용된 변수, 함수이름이 없는지 확인하기

## 문제 풀면서 배운 내용

- bfs에서 while q 사용시 return None 이 될수 있다는 것 잊지말기

  - 이 과정에서 결과를 sort하면 런타임에러 발생

  - 참고) bfs 이용한 최단거리 계산 알고리즘

    ```python
    def bfs(s):
        q = [s]
        dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        visited = [[0] * 4 for _ in range(4)]
        visited[s[0]][s[1]] = 1
        while q:
            # for i in range(4):
            #     print(visited[i])
            # print()
            x, y = q.pop(0)
            if [x, y] == [3, 3]:
                print(visited[x][y])
                break
            for i in range(4):
                nx = x + dirs[i][0]
                ny = y + dirs[i][1]
                if 0 <= nx < 4 and 0<= ny < 4:
                    if visited[nx][ny] == 0:
                        visited[nx][ny] = visited[x][y] + 1
                        q.append([nx, ny])
    
    
    a = [[0] * 4 for _ in range(4)]
    bfs([0, 0]) # [0, 0] ~ [3, 3] 까지 도달하는 최단 거리 계산하는 함수
    print(a)
    ```

    

## 기억할 개념

### 진수 변환

#### 10진수 → 2진수, 8진수, 16진수

##### 1. `bin()`, `oct()`, `hex()`내장 함수 이용

```python
print(bin(10)) # 0b1010
print(oct(10)) # 0o12
print(hex(10)) # 0xa
print(hex(16)) # 0x10
```

#### 2. `format()` 내장함수 이용

```python
print(format(8, '#b')) # 0b1000
print(format(8, '#o')) # 0o10
print(format(8, '#x')) # 0x8

# #을 제거해주면 변환된 값 자체만 출력 가능하다.
print(format(8, 'b')) # 1000
print(format(8, 'o')) # 10
print(format(8, 'x')) # 8
```

#### 2진수, 8진수, 16진수 → 10진수

##### `int` 함수 이용

```python
print(int('0b1010', 2)) # 10
print(int('0o12', 8)) # 10
print(int('0xa', 16)) # 10
```

### 몫과 나머지 한번에

divmod(a, b)

a를 b로 나눈다.

### 숫자 앞 0 붙이기

#### string`.zfill(width)`

- 문자열 타입 메서드
- 지정한 자리수보다 대상 문자열이 긴 경우 변화 X
- 문자열 앞에 +, - 부호가 있을 경우에도 적용 가능

```python
a = '123'
b = a.zfill(7)
print(a.zfill(5)) # 00123
print(a) # 123
print(b) # 0000123
```

#### string`.rjust(width[, fillchar])`

- fillchar를 채워서 스트링 길이 width를 맞추기
- fillchar 작성안할 경우 빈칸으로 채움

```python
a = "123"
b = a.rjust(5, "0")
c = a.rjust(7, "1")
print(a) # 123
print(b) # 00123
print(c) # 1111123
```

#### 정수에 사용

```python
a = "%05d" %5
print(a) # 00005
print(type(a)) # str
print("%07d"% 12) # 0000012

b = 123 
print('{0:05d}'.format(b)) # 00123

# cf) 소수점 표현
c = "%5f" %2.1
print(c) # 2.10000
```

## lambda 이용한 정렬

```python
a = [[1, 3], [2, 5], [1, 7], [3, 4]]
a = sorted(a, key=lambda x: (x[1], x[0])) # 우선 정렬할 것을 x[1]으로 지정하고 내림차순을 하고 싶은 경우 앞에 - 부호를 붙여주면 끝!
print(a) # [[1, 3], [3, 4], [2, 5], [1, 7]]
```

